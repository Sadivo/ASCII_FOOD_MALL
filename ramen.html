<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç…‰ç„è»’ â€” æ‹‰éºµåº—</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=Noto+Sans+TC:wght@400;900&display=swap');

        body {
            font-family: 'Courier Prime', 'Noto Sans TC', monospace;
            background-color: #000;
            color: #0f0;
            touch-action: none;
            user-select: none;
            overflow: hidden;
            height: 100vh;
        }

        @keyframes titleShake {

            0%,
            100% {
                transform: translateY(0);
                color: #0f0;
                text-shadow: 2px 2px #f59e0b;
            }

            25% {
                transform: translateY(-3px);
                color: #f59e0b;
                text-shadow: 2px 2px #0f0;
            }

            50% {
                transform: translateY(1px);
                color: #0f0;
                text-shadow: 2px 2px #f59e0b;
            }

            75% {
                transform: translateY(-1px);
                color: #f59e0b;
                text-shadow: 2px 2px #0f0;
            }
        }

        .page-title {
            font-size: 1.4rem;
            font-weight: 900;
            animation: titleShake 1.2s steps(4) infinite;
            letter-spacing: 1px;
            padding: 10px 0;
            text-align: center;
            border-bottom: 2px double #0f0;
            background: #000;
        }

        .shop-sign {
            font-size: 10px;
            color: #0f0;
            text-align: center;
            margin-top: 10px;
            line-height: 1.2;
            font-weight: bold;
            white-space: pre;
        }

        .back-btn {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 11px;
            color: #0f0;
            cursor: pointer;
            text-decoration: none;
            border: 1px solid #0f0;
            padding: 2px 8px;
            z-index: 20;
        }

        .back-btn:hover {
            color: #f59e0b;
            border-color: #f59e0b;
        }

        .score-board {
            font-size: 0.8rem;
            padding: 4px 10px;
            border-bottom: 1px double #0f0;
            display: flex;
            justify-content: space-between;
        }

        /* === Customer area === */
        .customer-ascii {
            font-size: 1.1rem;
            color: #0f0;
            opacity: 0.1;
            transition: all 0.3s;
        }

        .customer-active {
            opacity: 1;
        }

        .fullness-bar {
            font-size: 7px;
            color: #0c0;
            margin-top: 1px;
        }

        .order-bubble {
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            border: 1px solid #fff;
            color: #fff;
            padding: 3px 8px;
            font-size: 0.65rem;
            opacity: 0;
            background: #000;
            z-index: 50;
            white-space: nowrap;
        }

        /* === Counter bar (like sushi belt) === */
        .counter-bar {
            border-top: 2px dashed #0f0;
            border-bottom: 2px dashed #0f0;
            height: 42px;
            position: relative;
            background: #020;
        }

        .counter-arrows {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            font-size: 8px;
            opacity: 0.15;
            pointer-events: none;
        }

        /* Drop zones on counter for each seat */
        .counter-slot {
            position: absolute;
            top: 4px;
            width: 80px;
            height: 32px;
            border: 1px dashed #0a0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            color: #0a0;
            transition: all 0.3s;
        }

        .counter-slot-active {
            border-color: #f59e0b;
            color: #f59e0b;
            background: rgba(245, 158, 11, 0.05);
        }

        .counter-slot-filled {
            border-color: #0f0;
            color: #0f0;
            background: rgba(0, 255, 0, 0.05);
        }

        /* === Cooking area === */
        .hint-text {
            font-size: 13px;
            color: #f59e0b;
            text-align: center;
            margin: 4px 0;
            line-height: 1.4;
            opacity: 0.8;
        }

        .draggable-item {
            cursor: pointer;
            border: 1px solid #0f0;
            padding: 3px 7px;
            margin: 2px;
            background: #000;
            display: inline-block;
            text-align: center;
            font-size: 11px;
        }

        .drag-proxy {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            border: 1px solid #ff0;
            color: #ff0;
            background: #000;
            padding: 4px 12px;
            display: none;
            transform: translate(-50%, -50%);
            font-weight: bold;
        }

        .border-ascii {
            border: 1px solid #0f0;
            position: relative;
        }

        /* Bowl */
        .bowl-area {
            width: 180px;
            height: 100px;
            border: 2px solid #0f0;
            border-radius: 0 0 50% 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            background: #050505;
            overflow: hidden;
        }

        .soup-base {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 0;
            transition: height 0.5s;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0 0 50% 50%;
        }

        .soup-wave {
            position: absolute;
            top: -4px;
            width: 100%;
            text-align: center;
            font-size: 9px;
            animation: waveMove 1.5s linear infinite;
        }

        @keyframes waveMove {
            0% {
                transform: translateX(-5px);
            }

            50% {
                transform: translateX(5px);
            }

            100% {
                transform: translateX(-5px);
            }
        }

        /* Noodle cooking station */
        .cook-station {
            width: 130px;
            height: 80px;
            border: 2px solid #f59e0b;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            background: #0a0500;
        }

        .cook-station-water {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 50%;
            background: rgba(200, 200, 255, 0.08);
            border-top: 1px solid #333;
        }

        .cook-station .noodle-display {
            z-index: 5;
            font-size: 12px;
            font-weight: bold;
        }

        .noodle-timer {
            width: 100px;
            height: 12px;
            border: 1px solid #0f0;
            position: relative;
            overflow: hidden;
            margin-top: 4px;
        }

        .noodle-timer-fill {
            height: 100%;
            background: #0f0;
            transition: width 0.1s, background 0.3s;
        }

        .noodle-timer-text {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            color: #000;
            font-weight: bold;
            line-height: 12px;
        }

        /* Bubbling animation for cooking station */
        .bubble-particle {
            position: absolute;
            pointer-events: none;
            font-size: 8px;
            color: #aaf;
            z-index: 6;
            animation: bubbleUp 0.8s ease-out forwards;
        }

        @keyframes bubbleUp {
            0% {
                transform: translateY(0);
                opacity: 0.6;
            }

            100% {
                transform: translateY(-30px);
                opacity: 0;
            }
        }

        /* Steam */
        .steam-particle {
            position: fixed;
            pointer-events: none;
            font-size: 10px;
            color: #666;
            z-index: 10000;
            animation: steamFloat 1s ease-out forwards;
        }

        @keyframes steamFloat {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 0.5;
            }

            100% {
                transform: translate(var(--dx), -50px) scale(1.3);
                opacity: 0;
            }
        }
    </style>
</head>

<body class="flex flex-col">

    <div class="page-title relative">
        <a href="index.html" class="back-btn">â¬… å¤§å»³</a>
        ~.:: æ–‡å­—æ‹‰éºµåº— ::.~
    </div>

    <div class="score-board">
        <span>[ ç©åˆ†: <span id="score-val">0000</span> ]</span>
        <span>[ å‡ºé¤: <span id="total-serve">00</span> ]</span>
    </div>

    <!-- Customer Area -->
    <div class="flex flex-col justify-end bg-black">

        <!-- æ–¹æ¡†å°æ‹›ç‰Œå€ -->
        <div id="random-shop-sign" class="shop-sign"></div>

        <div class="flex justify-around items-end px-4 pb-4 mt-2">
            <div id="seat-0" class="relative flex flex-col items-center">
                <div class="order-bubble"></div>
                <div class="customer-ascii">( _ _ )</div>
                <div class="fullness-bar">[---------]</div>
            </div>
            <div id="seat-1" class="relative flex flex-col items-center">
                <div class="order-bubble"></div>
                <div class="customer-ascii">( _ _ )</div>
                <div class="fullness-bar">[---------]</div>
            </div>
            <div id="seat-2" class="relative flex flex-col items-center">
                <div class="order-bubble"></div>
                <div class="customer-ascii">( _ _ )</div>
                <div class="fullness-bar">[---------]</div>
            </div>
        </div>
    </div>

    <!-- === Counter Bar === -->
    <div id="counter-bar" class="counter-bar">
        <div class="counter-arrows">â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        </div>
        <div id="counter-0" class="counter-slot" style="left:calc(16.66% - 40px);">[ ç©º ]</div>
        <div id="counter-1" class="counter-slot" style="left:calc(50% - 40px);">[ ç©º ]</div>
        <div id="counter-2" class="counter-slot" style="left:calc(83.33% - 40px);">[ ç©º ]</div>
    </div>

    <div class="hint-text">
        <span class="text-[#0f0]">ã€ç§˜å‚³ã€‘</span>
        æ¹¯åº•â†’ç¢— | éºµâ†’ç…®éºµå°(ç­‰è¨ˆæ™‚) | ç†Ÿéºµâ†’ç¢— | é…æ–™â†’ç¢— | æˆå“æ‹–åˆ°å®¢äººå‰å‡ºé¤
        <span class="text-[#ff4444]"> !! éºµç…®å¤ªä¹…æœƒçˆ› !!</span>
    </div>

    <!-- === Cooking Area === -->
    <div class="flex-1 flex items-start justify-center p-1 gap-3 mt-1">

        <!-- Left: Noodle Cooking Station -->
        <div class="flex flex-col items-center space-y-1">
            <div class="text-[9px] text-[#f59e0b]">ã€ç…®éºµå°ã€‘</div>
            <div id="cook-station" class="cook-station">
                <div class="cook-station-water"></div>
                <div id="cook-noodle-display" class="noodle-display"></div>
            </div>
            <div id="timer-container" style="visibility:hidden;">
                <div class="noodle-timer">
                    <div id="timer-fill" class="noodle-timer-fill" style="width:0%"></div>
                    <div id="timer-text" class="noodle-timer-text">ç­‰å¾…ä¸­</div>
                </div>
            </div>
            <div class="border-ascii p-1 flex flex-row space-x-1">
                <div class="text-[9px] text-[#f59e0b] flex items-center">ã€ç”Ÿéºµã€‘</div>
                <div class="draggable-item" data-type="raw-noodle" data-val="ç´°éºµ">ç´°éºµ</div>
                <div class="draggable-item" data-type="raw-noodle" data-val="å¤ªéºµ">å¤ªéºµ</div>
                <div class="draggable-item" data-type="raw-noodle" data-val="ç¸®éºµ">ç¸®éºµ</div>
            </div>
        </div>

        <!-- Center: Soup -->
        <div class="flex flex-col items-center space-y-1">
            <div class="border-ascii p-1 flex flex-col space-y-1">
                <div class="text-[9px] text-center text-[#f59e0b]">ã€æ¹¯åº•ã€‘</div>
                <div class="draggable-item" data-type="soup" data-val="è±šéª¨">è±šéª¨</div>
                <div class="draggable-item" data-type="soup" data-val="å‘³å™Œ">å‘³å™Œ</div>
                <div class="draggable-item" data-type="soup" data-val="é†¬æ²¹">é†¬æ²¹</div>
                <div class="draggable-item" data-type="soup" data-val="é¹½å‘³">é¹½å‘³</div>
            </div>
        </div>

        <!-- Center-Right: Bowl -->
        <div class="flex flex-col items-center space-y-1">
            <div class="text-[9px] text-[#f59e0b]">ã€æ‹‰éºµç¢—ã€‘</div>
            <div id="drop-bowl" class="bowl-area">
                <div id="soup-fill" class="soup-base">
                    <div class="soup-wave">ï½ï½ï½ï½ï½ï½</div>
                </div>
                <div id="bowl-content" class="z-10 text-center">
                    <div id="bowl-toppings" class="text-[10px]"></div>
                    <div id="bowl-noodle" class="text-xs font-bold"></div>
                    <div id="bowl-soup-label" class="text-[9px]"></div>
                </div>
            </div>
            <div id="bowl-clear" class="text-[8px] text-[#555] cursor-pointer hover:text-[#f44]">[ å€’æ‰é‡ä¾† ]</div>
        </div>

        <!-- Right: Toppings & Spice -->
        <div class="flex flex-col items-center space-y-1">
            <div class="border-ascii p-1 grid grid-cols-2 gap-1">
                <div class="text-[9px] text-center col-span-2 text-[#f59e0b]">ã€é…æ–™ã€‘</div>
                <div class="draggable-item" data-type="topping" data-val="å‰ç‡’">å‰ç‡’</div>
                <div class="draggable-item" data-type="topping" data-val="åŠç†Ÿè›‹">åŠç†Ÿè›‹</div>
                <div class="draggable-item" data-type="topping" data-val="æµ·è‹”">æµ·è‹”</div>
                <div class="draggable-item" data-type="topping" data-val="è”¥èŠ±">è”¥èŠ±</div>
                <div class="draggable-item" data-type="topping" data-val="ç­å¹²">ç­å¹²</div>
            </div>
            <div class="border-ascii p-1 flex flex-row space-x-1">
                <div class="text-[9px] text-[#f59e0b] flex items-center">ã€è¾£åº¦ã€‘</div>
                <div class="draggable-item" data-type="spice" data-val="å¾®è¾£">å¾®è¾£</div>
                <div class="draggable-item" data-type="spice" data-val="ä¸­è¾£">ä¸­è¾£</div>
                <div class="draggable-item" data-type="spice" data-val="æ¿€è¾›">æ¿€è¾›</div>
            </div>
        </div>
    </div>

    <div id="drag-proxy" class="drag-proxy"></div>

    <script>
        const bowl = document.getElementById('drop-bowl');
        const soupFill = document.getElementById('soup-fill');
        const cookStation = document.getElementById('cook-station');
        const cookDisplay = document.getElementById('cook-noodle-display');
        const timerContainer = document.getElementById('timer-container');
        const timerFill = document.getElementById('timer-fill');
        const timerText = document.getElementById('timer-text');
        const proxy = document.getElementById('drag-proxy');
        const scoreEl = document.getElementById('score-val');
        const serveCountEl = document.getElementById('total-serve');
        const bowlClear = document.getElementById('bowl-clear');

        const soupColors = { 'è±šéª¨': '#e8d5b7', 'å‘³å™Œ': '#c4863c', 'é†¬æ²¹': '#5c3a1e', 'é¹½å‘³': '#d4d4aa' };

        let score = 0, serveCount = 0;
        let isDragging = false;
        let dragInfo = { type: '', val: '' };

        // Bowl state
        let bowlState = {
            soup: null, noodle: null, toppings: [], spice: null
        };

        // Cooking station state
        let cookState = {
            noodle: null, timer: 0, cooking: false,
            cooked: false, overcooked: false
        };

        const signEl = document.getElementById('random-shop-sign');

        const shopNames = [
            "ç…‰ ç„ è»’ â€§ æœ¬ åº—",
            "æ­» ç¥ â€§ æ‹‰ éºµ å±‹",
            "åœ° ç„ è±š éª¨ è™•",
            "ä¸‰ é€” â€§ è£½ éºµ æ‰€",
            "å¦– ç« â€§ æ¹¯ é ­ èˆ–"
        ];

        const customerPool = [
            "( ^_^ )", "( o_o )", "( >_< )", "( -_- )",
            "( *_* )", "( @.@ )", "( ^Ï‰^ )", "( â€¢Ì€Ï‰â€¢Ì )"
        ];

        let seats = [
            { id: 0, active: false, currentOrder: null, eaten: 0, capacity: 3, isEating: false },
            { id: 1, active: false, currentOrder: null, eaten: 0, capacity: 3, isEating: false },
            { id: 2, active: false, currentOrder: null, eaten: 0, capacity: 3, isEating: false }
        ];

        function init() {
            // éš¨æ©Ÿåº—åæ‹›ç‰Œæ¸²æŸ“
            const randomName = shopNames[Math.floor(Math.random() * shopNames.length)];
            const paddedName = ` ${randomName} `;
            const borderLine = "+" + "-".repeat(16) + "+";
            signEl.innerText = `${borderLine}\n|${paddedName}|\n${borderLine}`;

            setupPointerEvents();
            bowlClear.addEventListener('click', clearBowl);
            setInterval(manageSeats, 4000);
            setInterval(updateCookTimer, 100);
            setInterval(createSteam, 800);
            setInterval(createBubble, 400);
        }

        // === Steam & Bubble Effects ===
        function createSteam() {
            if (!bowlState.soup) return;
            const rect = bowl.getBoundingClientRect();
            const s = document.createElement('div');
            s.className = 'steam-particle';
            s.innerText = 'æ¹¯';
            s.style.left = (rect.left + Math.random() * rect.width) + 'px';
            s.style.top = (rect.top - 5) + 'px';
            s.style.setProperty('--dx', ((Math.random() - 0.5) * 25) + 'px');
            document.body.appendChild(s);
            setTimeout(() => s.remove(), 1000);
        }

        function createBubble() {
            if (!cookState.cooking) return;
            const rect = cookStation.getBoundingClientRect();
            const b = document.createElement('div');
            b.className = 'bubble-particle';
            b.innerText = 'Â°';
            b.style.left = (rect.left + 10 + Math.random() * (rect.width - 20)) + 'px';
            b.style.top = (rect.top + rect.height * 0.6) + 'px';
            cookStation.appendChild(b);
            setTimeout(() => b.remove(), 800);
        }

        // === Noodle Cooking Timer ===
        function updateCookTimer() {
            if (!cookState.cooking) return;
            cookState.timer += 1;
            const pct = Math.min(100, (cookState.timer / 100) * 100);
            timerFill.style.width = pct + '%';

            if (pct < 40) {
                timerFill.style.background = '#f59e0b';
                timerText.innerText = 'ç”Ÿ...';
            } else if (pct < 80) {
                timerFill.style.background = '#0f0';
                timerText.innerText = 'å‰›å¥½ï¼æ’ˆèµ·ä¾†ï¼';
                cookState.cooked = true;
            } else if (pct < 100) {
                timerFill.style.background = '#f44';
                timerText.innerText = 'å¿«çˆ›äº†ï¼';
            } else {
                cookState.cooking = false;
                cookState.overcooked = true;
                timerText.innerText = 'çˆ›æ‰äº†...';
                timerFill.style.background = '#555';
                cookDisplay.innerText = 'ğŸ’€ ' + cookState.noodle + 'ï¼ˆçˆ›ï¼‰';
                cookDisplay.style.color = '#555';
            }
        }

        // === Customer Management ===
        function manageSeats() {
            seats.forEach(seat => {
                if (!seat.active && Math.random() > 0.4) {
                    seat.active = true; seat.eaten = 0;
                    seat.capacity = 2 + Math.floor(Math.random() * 3);
                    const el = document.getElementById(`seat-${seat.id}`);
                    el.querySelector('.customer-ascii').innerText = customerPool[Math.floor(Math.random() * customerPool.length)];
                    el.querySelector('.customer-ascii').classList.add('customer-active');
                    generateOrder(seat);
                    updateFullnessBar(seat);
                    updateCounterSlot(seat.id);
                } else if (seat.active && !seat.isEating && !seat.currentOrder) {
                    generateOrder(seat);
                }
            });
        }

        function generateOrder(seat) {
            const soups = ['è±šéª¨', 'å‘³å™Œ', 'é†¬æ²¹', 'é¹½å‘³'];
            const tops = ['å‰ç‡’', 'åŠç†Ÿè›‹', 'æµ·è‹”', 'è”¥èŠ±', 'ç­å¹²'];
            const spices = ['', 'å¾®è¾£', 'ä¸­è¾£', 'æ¿€è¾›'];
            const s = soups[Math.floor(Math.random() * soups.length)];
            const sp = spices[Math.floor(Math.random() * spices.length)];
            const t = tops[Math.floor(Math.random() * tops.length)];
            seat.currentOrder = (sp || '') + s + 'æ‹‰éºµ+' + t;
            refreshBubble(seat);
        }

        function refreshBubble(seat) {
            const el = document.getElementById(`seat-${seat.id}`);
            const bubble = el.querySelector('.order-bubble');
            if (seat.currentOrder) {
                bubble.style.opacity = "1";
                bubble.innerText = `[ ${seat.currentOrder} ]`;
            } else {
                bubble.style.opacity = "0";
            }
        }

        function updateFullnessBar(seat) {
            const el = document.getElementById(`seat-${seat.id}`);
            const bar = el.querySelector('.fullness-bar');
            if (!seat.active) { bar.innerText = "[---------]"; return; }
            const filled = Math.min(9, Math.floor((seat.eaten / seat.capacity) * 9));
            bar.innerText = "[" + "#".repeat(filled) + "-".repeat(9 - filled) + "]";
        }

        function updateCounterSlot(seatId) {
            const slot = document.getElementById(`counter-${seatId}`);
            const seat = seats[seatId];
            if (!seat.active) {
                slot.innerText = '[ ç©º ]';
                slot.className = 'counter-slot';
            } else {
                slot.innerText = '[ ç­‰å¾… ]';
                slot.className = 'counter-slot counter-slot-active';
            }
        }

        // === Bowl Management ===
        function updateBowl() {
            document.getElementById('bowl-soup-label').innerText = bowlState.soup ? `ã€Š${bowlState.soup}ã€‹` : '';
            document.getElementById('bowl-noodle').innerText = bowlState.noodle || '';
            let tText = bowlState.toppings.join(' ');
            if (bowlState.spice) tText += (tText ? ' ' : '') + 'ğŸ”¥' + bowlState.spice;
            document.getElementById('bowl-toppings').innerText = tText;
        }

        function clearBowl() {
            bowlState = { soup: null, noodle: null, toppings: [], spice: null };
            soupFill.style.height = '0';
            updateBowl();
        }

        function isBowlComplete() {
            return bowlState.soup && bowlState.noodle;
        }

        function getBowlName() {
            let name = '';
            if (bowlState.spice) name += bowlState.spice;
            name += bowlState.soup + 'æ‹‰éºµ';
            if (bowlState.toppings.length > 0) name += '+' + bowlState.toppings[0];
            return name;
        }

        // === Drag & Drop ===
        function setupPointerEvents() {
            document.addEventListener('pointerdown', (e) => {
                // Check if clicking on the bowl to drag the completed ramen
                if (isBowlComplete()) {
                    const bowlRect = bowl.getBoundingClientRect();
                    if (e.clientX > bowlRect.left && e.clientX < bowlRect.right &&
                        e.clientY > bowlRect.top && e.clientY < bowlRect.bottom) {
                        isDragging = true;
                        dragInfo = { type: 'finished-bowl', val: getBowlName() };
                        proxy.style.display = 'block';
                        proxy.innerText = `[ ${dragInfo.val} ]`;
                        updateProxy(e);
                        return;
                    }
                }

                // Check if clicking on cook station to drag cooked noodle
                if (cookState.noodle && (cookState.cooked || cookState.overcooked)) {
                    const csRect = cookStation.getBoundingClientRect();
                    if (e.clientX > csRect.left && e.clientX < csRect.right &&
                        e.clientY > csRect.top && e.clientY < csRect.bottom) {
                        isDragging = true;
                        cookState.cooking = false; // stop cooking when picked up
                        const nVal = cookState.overcooked ? cookState.noodle + 'ï¼ˆçˆ›ï¼‰' : cookState.noodle;
                        dragInfo = { type: 'cooked-noodle', val: nVal, overcooked: cookState.overcooked };
                        proxy.style.display = 'block';
                        proxy.innerText = `[ ${nVal} ]`;
                        updateProxy(e);
                        return;
                    }
                }

                const target = e.target.closest('.draggable-item');
                if (!target) return;
                isDragging = true;
                target.releasePointerCapture(e.pointerId);
                dragInfo = { type: target.getAttribute('data-type'), val: target.getAttribute('data-val') };
                proxy.style.display = 'block';
                proxy.innerText = `[ ${dragInfo.val} ]`;
                updateProxy(e);
            });

            window.addEventListener('pointermove', (e) => {
                if (!isDragging) return;
                updateProxy(e);
            });

            window.addEventListener('pointerup', (e) => {
                if (!isDragging) return;
                isDragging = false;
                proxy.style.display = 'none';

                // Drop raw noodle on cook station
                if (dragInfo.type === 'raw-noodle' && isOver(e, cookStation)) {
                    if (!cookState.noodle) {
                        cookState = { noodle: dragInfo.val, timer: 0, cooking: true, cooked: false, overcooked: false };
                        cookDisplay.innerText = dragInfo.val;
                        cookDisplay.style.color = '#f59e0b';
                        timerContainer.style.visibility = 'visible';
                        timerFill.style.width = '0%';
                        timerText.innerText = 'ç…®éºµä¸­...';
                    }
                    return;
                }

                // Drop cooked noodle into bowl
                if (dragInfo.type === 'cooked-noodle' && isOver(e, bowl)) {
                    bowlState.noodle = dragInfo.val;
                    // Clear cook station
                    cookState = { noodle: null, timer: 0, cooking: false, cooked: false, overcooked: false };
                    cookDisplay.innerText = '';
                    timerContainer.style.visibility = 'hidden';
                    timerFill.style.width = '0%';
                    updateBowl();
                    return;
                }

                // Drop soup / topping / spice into bowl
                if (isOver(e, bowl)) {
                    if (dragInfo.type === 'soup' && !bowlState.soup) {
                        bowlState.soup = dragInfo.val;
                        soupFill.style.height = '50%';
                        soupFill.style.background = soupColors[dragInfo.val] || '#ccc';
                    } else if (dragInfo.type === 'topping' && bowlState.soup && bowlState.toppings.length < 3) {
                        if (!bowlState.toppings.includes(dragInfo.val)) {
                            bowlState.toppings.push(dragInfo.val);
                        }
                    } else if (dragInfo.type === 'spice' && bowlState.soup) {
                        bowlState.spice = dragInfo.val;
                    }
                    updateBowl();
                    return;
                }

                // Drop finished bowl on counter slot â†’ serve to customer
                if (dragInfo.type === 'finished-bowl') {
                    for (let i = 0; i < 3; i++) {
                        const slot = document.getElementById(`counter-${i}`);
                        if (isOver(e, slot) && seats[i].active && !seats[i].isEating) {
                            serveToCustomer(i);
                            return;
                        }
                    }
                }
            });
        }

        function serveToCustomer(seatId) {
            const seat = seats[seatId];
            const bowlName = getBowlName();
            const wasTarget = seat.currentOrder === bowlName;
            const isOvercooked = bowlState.noodle && bowlState.noodle.includes('ï¼ˆçˆ›ï¼‰');

            let pts = 0;
            if (isOvercooked) pts = 50;
            else if (wasTarget) pts = 500;
            else pts = 150;
            pts += bowlState.toppings.length * 30;
            if (bowlState.spice) pts += 20;

            score += pts;
            serveCount++;
            scoreEl.innerText = String(score).padStart(4, '0');
            serveCountEl.innerText = String(serveCount).padStart(2, '0');

            // Show on counter
            const slot = document.getElementById(`counter-${seatId}`);
            slot.innerText = `[${bowlState.soup}éºµ]`;
            slot.className = 'counter-slot counter-slot-filled';

            // Customer eats
            eatRamen(seat, wasTarget);

            // Clear bowl
            clearBowl();
        }

        function eatRamen(seat, wasTarget) {
            const el = document.getElementById(`seat-${seat.id}`);
            const bubble = el.querySelector('.order-bubble');
            const asciiEl = el.querySelector('.customer-ascii');
            const oldFace = asciiEl.innerText;

            seat.isEating = true; seat.eaten++;
            updateFullnessBar(seat);

            const good = ["(â˜†â–½â˜†) æ­¤æ¹¯æ·±å¾—æˆ‘å¿ƒï¼", "(*Â´âˆ€ï½€*) ä¸€ç¢—å…¥é­‚ï¼", "(à¹‘Â´Ú¡`à¹‘) æ¹¯é ­çµ•äº†!", "( â€¢Ì€Ï‰â€¢Ì ) è·äººä¹‹å‘³"];
            const ok = ["(ãƒ»_ãƒ») ä¹Ÿè¡Œå§...", "(ï¿£.ï¿£) å˜›,æœ‰å¾—åƒ", "(Â´ãƒ»Ï‰ãƒ»`) å¡«é£½è‚šå­"];

            bubble.style.opacity = "1";
            bubble.innerText = wasTarget ? good[Math.floor(Math.random() * good.length)] : ok[Math.floor(Math.random() * ok.length)];
            asciiEl.innerText = wasTarget ? "(â‰§â–½â‰¦)" : "(ãƒ»Îµãƒ»)";
            if (wasTarget) seat.currentOrder = null;

            setTimeout(() => {
                // Clear counter slot
                const slot = document.getElementById(`counter-${seat.id}`);

                if (seat.eaten >= seat.capacity) {
                    bubble.innerText = "(*ï¾Ÿâˆ€ï¾Ÿ) é£½äº†ï¼Œå¤šè¬æ¬¾å¾…";
                    setTimeout(() => {
                        bubble.style.opacity = "0";
                        asciiEl.innerText = "( _ _ )";
                        asciiEl.classList.remove('customer-active');
                        seat.active = false; seat.isEating = false;
                        seat.currentOrder = null;
                        updateFullnessBar(seat);
                        slot.innerText = '[ ç©º ]';
                        slot.className = 'counter-slot';
                    }, 1200);
                } else {
                    seat.isEating = false;
                    asciiEl.innerText = oldFace;
                    refreshBubble(seat);
                    slot.innerText = '[ ç­‰å¾… ]';
                    slot.className = 'counter-slot counter-slot-active';
                }
            }, 1500);
        }

        function updateProxy(e) { proxy.style.left = e.clientX + 'px'; proxy.style.top = e.clientY + 'px'; }

        function isOver(e, el) {
            const r = el.getBoundingClientRect();
            return e.clientX > r.left - 15 && e.clientX < r.right + 15 && e.clientY > r.top - 15 && e.clientY < r.bottom + 15;
        }

        init();
    </script>
</body>

</html>